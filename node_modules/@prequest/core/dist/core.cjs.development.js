'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var x = require('@xdoer/x');

class Middleware {
  constructor() {
    this.cbs = [];
  }

  exec(ctx, next, injectOpt) {
    if (injectOpt === void 0) {
      injectOpt = {};
    }

    let times = -1;
    const cbs = [...Middleware.globalCbs, ...this.cbs];

    const dispatch = function (pointer) {
      if (pointer === void 0) {
        pointer = 0;
      }

      if (cbs.length < pointer) return Promise.resolve();
      const fn = cbs[pointer] || next;
      if (pointer <= times) throw new Error('next function only can be called once');
      times = pointer;
      return fn(ctx, () => dispatch(++pointer), injectOpt);
    };

    return dispatch();
  }

  use(cb) {
    this.cbs.push(cb);
    return this;
  }

  static use(cb) {
    Middleware.globalCbs.push(cb);
    return Middleware;
  }

}
Middleware.globalCbs = [];

const METHODS = ['get', 'post', 'delete', 'put', 'patch', 'head', 'options'];

class PreQuest extends Middleware {
  constructor(adapter, config) {
    super();
    this.adapter = adapter;
    this.config = config;
    this.mount();
  }

  mount() {
    const preQuest = this;
    METHODS.forEach(method => {
      preQuest[method] = (path, config) => {
        const request = x.merge(PreQuest.defaults, this.config, {
          path,
          method: method.toUpperCase()
        }, config);
        const response = {};
        return this.controller({
          request,
          response,
          context: this
        });
      };
    });
  }

  request(path, config) {
    const request = x.merge(PreQuest.defaults, this.config, typeof path === 'string' ? {
      path,
      ...config
    } : path);
    const response = {};
    return this.controller({
      request,
      response,
      context: this
    });
  }

  async controller(ctx, opt) {
    if (opt === void 0) {
      opt = {};
    }

    await this.exec(ctx, async ctx => {
      ctx.response = await this.adapter(ctx.request);
    }, opt);
    return ctx.response;
  }

  static create(adapter, config) {
    const instance = new PreQuest(adapter, config);

    const request = (path, config) => {
      return instance.request(path, config);
    };

    Reflect.setPrototypeOf(request, instance);
    return request;
  }

}
PreQuest.defaults = {};

exports.PreQuest = PreQuest;
//# sourceMappingURL=core.cjs.development.js.map
